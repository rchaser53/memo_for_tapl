# 高階多相
## 定義
- SystemFωはSystemFとλωを組み合わせて構成
- 型変数が束縛される箇所(型抽象と型量化子)にカインド付け注釈(X::K)が追加される

### 省略記法
- ∀X::*.T   => ∀X.T
- {∃X::*,T} => {∃X,T}

## 強化
- Γ,x:S,ΔT::KならばΓ,ΔT::K

## 並べ替えと弱化
Γ,Δという文脈があり、あるΣに対してΔはΓ,Σの並べ替えで正しい形式(30.3.18)を持つこととする。つまりΔはΓの拡張の並べ替えである
1. Γ|-T::Kならば、Δ|-T::K
2. Γ|-t:Tならば、 Δ|-t:T

## 項の代入
Γ,x:S,Δ|-t:TかつΓ|-s:Sならば、Γ,Δ|-[x->s]t:T

## 型の代入
1. Γ,Y::J,Δ|-T::KかつΓ|-S::Jならば、Γ,[Y->S]Δ|-[Y->S]T::K
2. T≡Uならば[Y->S]T≡[Y->S]U
3. Γ,Y::J,Δ|-t:TかつΓ|-S::JならばΓ,[Y->S]Δ|-[Y->S]t:[Y->S]T

## 型等価性と簡約
### 並行簡約
- Fωに置ける型付けの性質を証明するには、型等価関係に向きを与えたものを用いる
- 型等価性との違いは対称律と推移律が外されたこと
- QR-APPABSの規則が簡約基の一部分を同時に簡約することを許していること
  - 例. (λX::K11.T12)T2は[X->T2]T12に簡約されるが逆方向に簡約はできない
- 推移的対称的閉包(<=>*)が型等価性と一致すること
  - S≡Tの時、かつその時に限りS<=>*T
- 合流性をもつ(Church-Rosser性)

#### 補題
- S=>S'ならば、任意の型Tに対して[Y->S]T=>[Y->S']T
- S=>S'かつT=>T'ならば[Y->S]T=>[Y->S']T'

## 簡約の単一ステップでのダイヤモンド性
- S=>TかつS=>Uならば、ある型Vが存在してT=>VかつU=>V

## 合流性
- S=>*TかつS=>*ならば、ある型Vが存在してT=>*VかつU=>*V
- S<=*Tならば、あるUが存在してS=>*UかつT=>*U
  - 二つの肩が等価ならば、共通の簡約結果をもつ
  - 逆転の性質を証明するために必要な構造が得られる
- S≡Tならば、あるUが存在してS=>*UかつT=>*U

## 簡約の下での形の保存
1. S1->S2=>*Tならば、T=T1->T2であり、この時S1=>*T1かつS2=>*T2
2. ∀X::K1.S2=>*Tならば、T=∀X::K1.T2であり、この時S2=>*T2

## 逆転
1. Γ|-λx:S1.s2: T1->T2ならば、T1≡S1かつΓ,x:S1|-s2:T2。さらにΓ|-S1::*
2. Γ|-λX::J1.s2: ∀X::K1.T2ならば、J1=K1かつΓ,X::J1|-s2:T2

## 保存
- Γ|-t:Tかつt->t'ならば、Γ|-t':T

## 標準形(進行)
1. tが閉じた値で、|-t:T1->T2ならば、tは抽象である
2. tが閉じた値で、|-t:∀X::K1.T2ならば、tは肩抽象である

## 進行
- tを閉じた正しく型付けされた項とする(つまりあるTに対して|-t:T)
- この時tは値であるか、さもなくばあるt'が存在してt->t'

## カインド付け
- 文脈Γは次のいずれかの条件を満たす時、正しい形式を持つ
1. Γは空である
2. Γ=Γ1,x:T、ただしΓ1は正しい形式を持ち、Γ1|-T::*
3. Γ=Γ1,X::K、ただしΓ1は正しい形式を持つ

- Γ|-t:TかつΓが正しい形式を持つならば、Γ|-T::*

## 制限されたFω
- SystemF1においては、カインドは*だけで型の量化(∀)や抽象(λ)は許さない
- 他の体系はレベルiのカインド(以下に定義)の階層構造を用いて定義できる
  - K1    = ∅
  - Ki+1  = {*} ∪ {J⇒K | J∈Ki かつ K∈Ki+1}
  - Kω    = U1≤i Ki
- SystemFがしばしば二階ラムダ計算と呼ばれる

## おさらい
単純型付きラムダ計算:      項の中の部分項を抽象化する操作を形式化した
                        => 後で異なる項に適用して具体化できる関数が得られた
SystemF:                項の中の型を抽象化する操作を考えた
                        => さあまざまな型に適用して具体化できる項を得られた
λω:                     単純型付きラムダ計算の仕組みを「1レベル上げて」反復した
                        この仕組みは型を受け取り、その部分式を抽象化する
                        => 後で異なる型に適用することで具体化できる型演算子を得た

## インデックス付けされた式の族
- 通常のラムダ抽象λx:T1.t2は項sでインデックス付けされた項[x->s]t2の族
- 同様に型抽象λX::K1.t2は型でインデックス付された項の族
- 型演算子は型でインデックス付けされた型の族
- 例:
  - λx:T1.t2      項でインデックス付けされた項の族
  - λX::K1.t2     型でインデックス付けされた項の族
  - λX::K1.T2     型でインデックス付けされた型の族

## 依存型
- 項でインデックス付けされた型
  - 単純な型FLoatListを詳細化して型の族FloatList n、すなわちn個の要素を持つリストの型とすることができる

## 依存関数型
- Πx：T1.T2という型をは矢印型T1->T2をより正確にした形式
- ここで関数の引数を表す変数xを束縛することで、返り値の型T2の中でその引数を参照できるようにする
- 縮退している場合、つまりT2がxに言及していない場合にはΠx:T1.T2をT1->T2と書く

- sort: Πn:Nat.FloatList n -> FloatList n
  - この型からは、このソート関数が返すリストは引数と同じ長さだとわかる
  - 実際、関連する型の族をもっと詳細化することで返り値のリストが常にソートされていることがわかる型をもつsort関数すらかける
  - 関数sortが実際にこの型に属すことを検査することは、要するに関数がその仕様を満たしていることを証明するのと同じ

