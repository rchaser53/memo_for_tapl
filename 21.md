# 再帰型のメタ理論
- 余帰納法
- 単調
- F∈P(U)->P(U)は、X⊆YならばF(X)⊆F(Y)
- P(U)がUの全ての部分集合の集合
- 生成関数
  - P(U)上の何らかの単調関数

## XをUの部分集合とする
- F(X)⊆Xである時、Xは「Fについて閉じている」
- X⊆F(X)である時、Xは「Fについて整合的である」
- F(X)=Xである時、XはFの不動点

- Fを「正当化」と呼んでいる

## 不動点
- Fについて閉じている全ての集合の共通部分はFの最小不動点(μF)
- Fについて整合的な全ての集合の和集合はFの最大不動点(vF)

### 帰納法原理
- XがFについて閉じているならばμF⊆X

### 余帰納法原理
- XがFについて整合的ならばX⊆vF

## 記法
- {1,2}*     1と2からなる列からなる集合
- ●          空集合
- π,σ        πとσの連結

## 木型(もしくは単に木)
以下の制約を満たす部分関数T∈{1,2}* -> {->,X,Top}
- T(●)
- T(π,σ)
- T(π)=->もしくはT(π)=XならばT(π,1)とT(π,2)は定義されている
- T(π)=TopならばT(π,1)とT(π,2)は未定義

- 全ての木型の集合T
- 有限の木型からなる部分集合Tf

### 色々な便宜上の表現
- T(•)=Topである木TをTop
- T1とT2が木であるとき
  - T1×T2で(T1×T2)(•)=×かつ(T1×T2)(i,π)=Ti(π)である木
  - T1→T2で(T1→T2)(•)=→かつ(T1→T2)(i,π)=Ti(π)である木（ただしi=1,2）

#### 例
- (Top×Top)→Top
  - 関数T(•)=→、T(1)=×、T(2)=T(1,1)=T(1,2)=Topで定義される有限の木型を表す

- 「...」で有限でない木型を表す
  - 例: Top→(Top→(Top→...)) 以下の条件を満たす関数によって定義される型Tに対応
    - すべてのk≥0についてT(2k)=→かつ
    - すべてのk≥0についてT(2k,1)=Top


- Tfは上記の文法規則で作られた生成関数の最小不動点
- この生成関数

# 推移律
- 宣言的な表現
  - 推移律を明示的に含んでいる
- アルゴリズム的な表現
  - 推移律を明示的には含んでいない

# 所属性検査
ある普遍集合U上の生成関数Fと要素x∈Uを与えられた時にxがFの最大不動点に含まれるか否か

## 可逆
- 生成集合
  - 与えられた要素x∈UをFで生成する方法は一般には複数ある
  - すなわち集合X⊆Uでx∈F(X)である様な物は複数存在
  - そのような集合Xをxの生成集合と呼ぶ

- 可逆
  - xが高々一つの極小な生成集合しか持たない様な生成関数
  - 生成関数Fは任意のx∈U(Gx = {X⊆U | x∈F(X)})について以下のどちらかの条件を満たす
    - 空である
    - 他の全ての要素の部分集合である一意な要素を含む

- 支持関数（support function）
  - Fが可逆であるとき
部分関数supportF ∈ U->P(U)を以下のように定義する

- supportF(x)
  X X∈Gxかつ∀X0∈Gx.X⊆X0の場合
  ↑ Gx=∅の場合
  
支持関数は以下のように集合に対しても定義しておく

supportF(X)=
∪x∈XsupportF(x) ∀x∈X.supportF(x)↓の場合
↑               それ以外の場合

## 記法の説明
- 文脈からFが明らかである場合には、supportFの添字を省略することが多い
- supportのような関数fは特別な値「失敗」を値域に含む
  - f(x)↓はfをxへと適用した結果が値になること
  - f(x)↑はfがxで失敗すること(f(x)=↑)

## 目的
- 生成関数Fの最小不動点、最大不動点に対する所属性検査を行うアルゴリズムの開発
- 基本的な手順は「Fの逆向きの実行」
  - どのようにxがFによって生成されるのか問う必要がある
- Fが可逆であることの利点はxを生成する方法が高々1つしかないこと

## 支持
- supportF(x)↓ Fに支持されている
  - Fに支持されている要素、supportF(x)=∅ である時にFの基底
- そうでない時、Fに支持されていない

- 添字"a"は仮定(assumption)を意味する

## 正則
- 木型T∈T'はsubtrees(T)が有限であるとき、即ち異なった部分木を有限子しか持たないときに正則
- 正則な木型の集合をT'rで表す
- 無限木の中にも正則なものが存在する
  - T = Top X (Top X (Top X ...))
- 木型Sが木型Tの部分木であるとkは S = λσ.T(π,σ)となるπが存在すること
  - パスから記号への関数Sが関数Tに与えるパスの引数に定数πを前置することで関数Tから得られる場合
  - 接頭辞πはTの根からSの根のパスへ対応する
  - Tのすべての部分木の集合をsubtrees(T)で表す

## μ型
生(raw)のμ型の集合Traw,m
T ::= X
      Top
      TxT
      T->T
      μX.T

## 縮小的
- 構文記号μは束縛子
- 生のµ型Tは、TのµX.µX1...µXn.Sという形の任意の部分式
  - 本体SがXではないときに縮小的
  - 生のμ型は縮小的であるとき単にμ型と呼ぶ。μ型の集合をTm
  - Tがμ型であるとき、Tのμ束縛の数をμ-height(T)と書く

### 帰納的定義
treeof(Top)(●)        = Top
treeof(T1->T2)(●)     = ->
treeof(T1->T2)(i,π)   = treeof(Ti)(π)
treeof(T1XT2)(●)      = X
treeof(T1XT2)(i,π)    = treeof(Ti)(π)
treeof(μX.T)(π)       = treeof([X->μX/T]T)(π)

## 部分関係
2つのμ型SとTは(S,T)∈vSm である時、部分型関係にある

### 備考
Sd中のdはμ畳み込みのSmで用いている「アルゴリズム的」な推論規則ではなく「宣言的(declarative)」な推論規則に基づいた関数である

生のμ型T中の自由なXの出現をSで置換する捕獲回避代入[X->S]T
treeof(vSm)はtreeofを各要素に対して適用した{treeof(T)|T∈vSm}

# 停止性の証明
以下の両方の集合を定義し前者が後者の部分集合であることを示すという流れになる

**トップダウンとボトムアップの記号を調達しないと駄目。トップダウンが⊆とボトムアップが<では無理がある**

## トップダウン部分式
- supportSmで生成される部分式に直接対応
- μ型Sはμ型Tのトップダウン部分式であるとは、二つ組(S,T)が以下に示す生成関数の最小不動点に含まれること
- S⊆Tと書く
TD(R)         = {(T,T)|T∈Tm}
              ∪ {(S,T1xT2)|(S,T1)∈R}
              ∪ {(S,T1XT2)|(S,T2)∈R}
              ∪ {(S,T1->T2)|(S,T1)∈R}
              ∪ {(S,T1->T2)|(S,T2)∈R}
              ∪ {(S,μX.T)|(S,[X->μX.T]T)∈R}

- (S',T') ∈ supportSm(S,T)ならば
  - S'⊆SもしくはS'⊆Tのどちらか一方が成り立つ
  - かつT'⊆SもしくはT'⊆Tのどちらか一方が成り立つ
  - トップダウン部分式関係は推移的

- (S',T')∈reachableSm(S,T)ならば、S'⊆SまたはS'⊆Tで有り、かつT'⊆SまたはT'⊆T

## ボトムアップ部分式
- 任意の閉じたμ型の部分式の集合が有限であることの単純な証明を支えている
- μ型Sがμ型Tのボトムアップ部分式であるとは、二つ組(S,T)が以下の生成関数の最小不動点に含まれること
- S<Tと書く
BU(R)         = {(T,T)|T∈Tm}
              ∪ {(S,T1xT2)|(S,T1)∈R}
              ∪ {(S,T1XT2)|(S,T2)∈R}
              ∪ {(S,T1->T2)|(S,T1)∈R}
              ∪ {(S,T1->T2)|(S,T2)∈R}
              ∪ {([X,μX.T]S,μX.T)|(S,T)∈R}

## トップダウンとボトムアップの差
- μ束縛子で始まる型の節のみ
- その様な型のトップダウン部分式を得るには、最初に展開を行い展開結果の部分式を集めていた
- ボトムアップ部分式を得るには、最初に本体の(閉じているとは限らない)部分式を集める
  - それから展開の代入を適用することで閉じた式へとする

- S<[X->Q]T ならばS<Q が成り立つか S'<T が存在してS=[X->Q]S'が成り立つ

- S⊆TならばS<T

## Amber規則
同型再帰方部分型付けの一種


Σ, X<:Y |- S<:T
---------------
Σ|-μX.S<:μY.T

仮定(assumption)の集合Σの下でμX.SがμY.Tであることを示すには
- 追加の仮定X<:YのもとでS<:Tを示せば十分である
- Σは単に再帰変数の二つ組の集合、既に考慮してきている再帰型の二つ組を記録した物
- 両辺に束縛構文があるほとんどの規則と異なり、規則の適用前に束縛変数XとYの名前を相異なる様に付け替える必要あり

これらの仮定は以下のもう一つの部分型付け規則によって用いられる
(X<:Y)∈Σ
--------
Σ|-X<:Y

既にX<:Yを仮定しているなら、それを結論することができる

再帰型SとTで同値再帰的な型付けではS<:TだがAmber規則ではそうではない物
μX.Tと[X->μX.T]T、μX.Nat X (Nat X x)とμX.Nat X x