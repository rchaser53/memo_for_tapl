-　他の型を代入(または具体化)できる型変数

## 型変数に代入する操作を2つに分ける
- 型変数から型への写像σ(型代入と言われる)を定義すること
- この対応を具体的な型Tに適用して具体型σTを得ること

### 例
- σ = [X->Bool]
- σを型X->Xに適用
  - σ(X->X) = Bool->Bool

## 型代入
- σに含まれる型変数の集合dom(σ)
- 型の集合range(σ)
- 代入の定義域(dom)、値域(range)に同じ変数が現れうる

### 例
- [X->Bool, Y-> X->X]
- XをBoolに対応づける
- YをX->Xに対応づける

σとγが代入である時、それらを以下の様に合成して得られる代入をσ.γと書く
σ.γ
= X->σ(T)       (X->T)∈γである場合
  X->T          (X->T)∈σあり、X̸̸̸/∈γ
(σ.γ)S = σ(γS)であることに注意

型変数を含む項が正しく型付けされているならば、その項の代入による具体かも全て正しく型付けされる
σが任意の型代入で、かつΓ|-t:TならばσΓ|-σt:σT

## 2つの視点
(1)「tの全ての代入による具体化は正しく型付けされるだろうか」
=> 全てのσに対してσΓ|-σt:TなるTが存在するだろうか
(2)「tのある代入による具体化は正しく型付けされるだろうか」
=> σΓ|-σt:TなるTが存在する様なσは見つけられるだろうか

- (1)に関して型変数は型検査の間は抽象的なままであるべき
- Γ:文脈、t:項　(Γ,t)の解、σΓ|-σt:Tとなる組(σ,T)

f:X,a:Y, t=fa

t=XY

X: Y->a
Y: a

## 単一化
- 制約集合Cは等式の集合{Si=Ti i∈1..n}
- SとTの代入による具体化σSとσTが同一になる時、代入σは等式S=Tを単一化するという
- σがCの全ての等式を単一化する時、σはCを単一化する(または充足する)

## 制約型付け関係
- Γ|-t:T |x C は「制約Cが充足されるならば、項tはΓの前提の元で型Tを持つ」
  - Γ|-t:T|Cと書かれることもある
- FV(T)はTに現れる型変数の集合を表す
- 下付き文字のxを用いて、各部分導出において導入される型変数を追える様にし、異なる部分導出で作られるフレッシュな変数が実際に異なるものであることを保証している

- 以下の2つが保証されている
  - ある導出の最後の規則で型変数が選ばれた時は必ず、その型変数は部分導出の中で選ばれたどの変数とも異なる
  - 規則が二つ以上の部分導出を含む時は必ず、各部分導出で選ばれた変数の集合がいずれも重複しない
- これらの条件が与えられrた項に対する導出の構築そのものを妨げはしない
- 異なる箇所で同じ変数をフレッシュな物として用いた導出を構築してしまわない様にする

### 制約型付けのアイディア
|-λx:X.λy:Y.λz:Z.(xz)(yz):S|x C があるとする
- 項tと文脈Γが与えられた時、tがΓの下で型付け可能かどうか以下の要領で検査できる
- tが型を持つために充足されるべき制約Cを集め、同時に結果の型Sを求める
- SはCと型変数を共有し、その型変数の観点からtが持ちうる型を特徴つける型
- tの解を見つけるために、Cを充足する(C内の全ての等式の両辺を同一にする)代入σを探す
- その様な任意のσに対して、型σSはtが持ちうる型になる
- Cを充足する代入が存在しないと判明した場合、型付け可能にする様にtを具体化することはできない

#### 例
- t = λx:X->Y.x0
- アルゴリズムが生成する制約集合Cは[X->Y = Nat->Z]
- これに対応する結果の型Sは(X->Y)->Z
- 代入σ=[X->Nat, Z->Bool, Y->Bool]
- 式 X->Y = Nat->Zの両辺を同一にする
- σ((X->Y)->Z),つまり(Nat->Bool)->Boolはtが持ちうる型である

### 定義
Γ|-t:S|C
- (Γ,t,S,C)の解とはσがCを充足し、かつσS=Tとなる様な組(σ,T)
- 文脈Γと項tが与えられた時、Γとtの型変数を具体化して妥当な型付けを生成する方法には以下の2つがある
  - 宣言的な方法: (Γ,t)の全ての甲斐集合として表現する
  - アルゴリズム的な方法: 制約型付け関係を通して、Γ|-t:S|Cを満たすSとCを見つけ、それから(Γ,t,S,C)の解の集合を得る
- 二つの表現は等価である
1. (Γ,t,S,C)の解は全て(Γ,t)の解でもある(a)
2. (Γ,t)の解は全て、制約生成で導入された型変数に値を与えることで(Γ,t,S,C)の解に拡張できる(b)

#### 制約型付けの健全性(a)
Γ|-t:S|Cとする。もし(σ,T)が(Γ,t,S,C)の解であれば、それは(Γ,t)の解でもある

- Xに含まれる変数の全てに対して未定義で、他の変数にはσと同じ様に振舞う代入をσ\X

#### 制約型付けの完全性(b)
Γ|-t:S|xCとする。(σ,T)が(Γ,t)の解であり、かつdom(σ)∩X=∅ならば、σ'\X=σとなる様な(Γ,t,S,C)の解(σ',T)が存在する

- Γ|-t:S|Cとする。(Γ,t)の解が存在する時、かつその時に限り(Γ,t,S,C)の解が存在する

## gensym
- CT-APPにおけるフレッシュな型変数名の非決定的な選択は呼ばれるたびに新しい型変数

## 最良
その解から他の解を直接生成できるという意味

- 制約集合の解の計算方法
  - 単一化を用いて解の集合が空でないことを検査
  - 空でなければ最良の方法を見つける

## 限定的でない
- σとσ'についてσ'＝γ.σとなる様な代入γが存在する時、
  - σはσ’より限定的でない(またはより一般的)
  - σ⊆σ’と書く

## 主要単一化子(最汎単一化子)
- Cを充足し、またCを充足する任意の代入σ'に対してσ⊆σ'となる様な代入σ
- Cを充足する任意の代入を単に単一化子
