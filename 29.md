# 型演算子とカインド
## ここまで
- CBool = ∀X.X->X->X
  - 単なる省略
- Pair Y Z = ∀X.(Y->Z->X)->X;
  - パラメータ付き省略(型演算子)

## これから
- λx:∀X.(Nat->Bool->X)->X.xの代わりに
  - λx:Pair Nat Bool.x

## カリー化
- 通常の関数と同じように複数の引数を取る型関数は、カリー化によって1引数関数から組み上げることができる
- 例えば型関数λY.λZ.∀X.(Y->Z->X)->Xは2引数関数を表現している

- (λX::K11.T12)T2≡[X->T2]T12
- Γ|-t:S    S≡T
  -------------
     Γ|-t:T

## カインド
- 型の型。単純型付きラムダ計算を「1レベル上」に複製したもの
- 無意味な型式を防ぐのに使う
- 矢印型から項の引数の数がわかるのと同様に、型式を引数の数によって分類する
- カインドは一つの原子カインド(*と書き「型」と読む)
- 一つの構築子=>から構築される
  - *           真の型のカインド(BoolやBool->Bool)
  - *=>*        型演算子のカインド(真の型から真の型への関数)
  - *=>*=>*     真の型から型演算子への関数のカインド(2引数の型演算子)
  - (*=>*)=>*   型演算子から真の型への関数のカインド(高階型演算子)

- 通常の型に限定したい場合は「真の型」と呼ぶ
  - Nat->Natや∀X.X->Xのような通常の型とλX.Xのような型演算子をどちらも型と呼ぶため

- 型式が正しくカインド付けされているか検査する問題を簡単にするため、型レベルの抽象の束縛変数に対しカインドを注釈する
  - Pair = λA::*. λB::*. ∀X. (A->B->X) -> X;
  - このような型注釈はほとんど全て*なので今まで通りλX.Tと書いたら、λX::*.Tの省略であることにする

## カインドレベル
- 最も単純なカインドは*である
  - これは真の型すべてを要素とする

## 型レベルの式∀X.X->XとλX.X->Xの意味の違い
- ∀X.X->Xは真の型
  - ex. λX.λx:X.xなど
  - 多層関数であり、型Tで具体化されるとTからTへの関数を返す
- λX.X->Xは型演算子
  - 型Tに適用されるとTからTへの関数を要素としてもつ真の型T->Tを返す

- ∀X.X->Xは、その要素が型から項への項レベル関数であるような型
- λX.X->Xは、それ自身が(型から型への)関数
- この型自体を((λX.X->X)Tと書いて)型Tで具体化すると、型T->Tそのものを返すのであって、その要素を返すわけでない
  - fnが型∀X.X->Xを持ちOp=λX.X->Xとすると、fn[T]:T->T=OpT

## 具体例
- Javaの総称型: 新しい型演算子を定義する機能
- MLのdatatype: 型演算子の仕組みの一部

## パラメータ付きデータ型
- type 'a Tyop = tyoptag of ('a->'a)
  - 以下のように書く Tyop = λX.<tyoptag:X->X>;
  - MLでは任意のパラメータ型ではなく、パラメータ付きのバリアント型だけを定義できる
    - 型レベルでTyopがプログラムに現れる時は常に対応するタグtyoptagが項レベルで現れること

## 様々なカインドのシステム
- レコードのカインド: 要素が型のレコード、レコードの型ではない。相互再帰する型の体系を定義する自然な方法を提供する
- 列カインド: フィールドの列。これを用いると列変数多相を持つ体系に置いてレコード型を組み立てることができる
- 冪カインド(冪型): 部分型の別の形式化を与える
- 一元カインド: 定義に関連する。またはシェアリングを持つモジュールシステムにも関連する
- 依存カインド: 依存型の「1レベル上」の類似物
